<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SkyGuard Tactical - Drone Detection</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0a1929 0%, #001e3c 50%, #0a1929 100%);
            color: #e3f2fd;
            min-height: 100vh;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 20% 50%, rgba(41, 182, 246, 0.08) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(0, 188, 212, 0.06) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        header {
            background: rgba(13, 71, 161, 0.15);
            backdrop-filter: blur(20px);
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 20px;
            position: relative;
            border: 1px solid rgba(41, 182, 246, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #29b6f6, #00bcd4, transparent);
        }

        h1 {
            font-size: 36px;
            margin-bottom: 5px;
            font-weight: 300;
            letter-spacing: 2px;
            color: #e3f2fd;
            text-shadow: 0 0 20px rgba(41, 182, 246, 0.5);
        }

        .subtitle {
            color: #b0bec5;
            font-size: 13px;
            letter-spacing: 2px;
            font-weight: 400;
        }

        .status-bar {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .status-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            background: rgba(13, 71, 161, 0.2);
            border: 1px solid rgba(41, 182, 246, 0.3);
        }

        .status-badge.connected {
            background: rgba(38, 198, 218, 0.15);
            border-color: rgba(38, 198, 218, 0.5);
            color: #26c6da;
        }

        .status-badge.disconnected {
            background: rgba(239, 68, 68, 0.15);
            border-color: rgba(239, 68, 68, 0.5);
            color: #ef5350;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }

        .status-dot.pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .main-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: rgba(13, 71, 161, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid rgba(41, 182, 246, 0.25);
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.3);
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, #29b6f6, #00bcd4, transparent);
        }

        .threat-status {
            text-align: center;
            padding: 40px;
            border-radius: 16px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .threat-status.clear {
            background: rgba(10, 30, 20, 0.6);
            border: 2px solid #4ade80;
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.3);
        }

        .threat-status.possible {
            background: rgba(30, 30, 10, 0.6);
            border: 2px solid #fbbf24;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.3);
        }

        .threat-status.detected {
            background: rgba(30, 20, 10, 0.6);
            border: 2px solid #fb923c;
            box-shadow: 0 0 25px rgba(251, 146, 60, 0.4);
            animation: pulseDanger 2s ease-in-out infinite;
        }

        .threat-status.high {
            background: rgba(30, 10, 10, 0.6);
            border: 2px solid #ef4444;
            box-shadow: 0 0 30px rgba(239, 68, 68, 0.5);
            animation: pulseCritical 1.5s ease-in-out infinite;
        }

        @keyframes pulseDanger {
            0%, 100% { box-shadow: 0 0 25px rgba(251, 146, 60, 0.4); }
            50% { box-shadow: 0 0 35px rgba(251, 146, 60, 0.6); }
        }

        @keyframes pulseCritical {
            0%, 100% { box-shadow: 0 0 30px rgba(239, 68, 68, 0.5); }
            50% { box-shadow: 0 0 45px rgba(239, 68, 68, 0.8); }
        }

        /* Value flash animation */
        @keyframes valueFlash {
            0% {
                background: transparent;
                color: inherit;
            }
            50% {
                background: rgba(0, 188, 212, 0.3);
                color: #e3f2fd;
                box-shadow: 0 0 10px rgba(0, 188, 212, 0.5);
            }
            100% {
                background: transparent;
                color: inherit;
            }
        }

        .info-value.flash {
            animation: valueFlash 0.4s ease-out;
            border-radius: 3px;
        }

        .threat-text {
            font-size: 48px;
            font-weight: 700;
            letter-spacing: 2px;
            margin-bottom: 10px;
            font-family: 'Orbitron', monospace;
            text-transform: uppercase;
        }

        .confidence-text {
            font-size: 24px;
            font-weight: 500;
            opacity: 0.85;
        }

        .card h3 {
            font-size: 14px;
            margin-bottom: 20px;
            color: #ffa726;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 500;
            border-bottom: 1px solid rgba(255, 167, 38, 0.2);
            padding-bottom: 10px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid rgba(41, 182, 246, 0.1);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            color: #78909c;
            font-size: 13px;
            font-weight: 400;
        }

        .info-value {
            font-weight: 500;
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            color: #ffffff;
        }

        .metric {
            margin-bottom: 20px;
        }

        .metric-label {
            color: #78909c;
            font-size: 11px;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 500;
        }

        .metric-value {
            font-size: 32px;
            font-weight: 300;
            letter-spacing: 1px;
        }

        .metric-value.green {
            color: #26c6da;
        }
        .metric-value.blue {
            color: #ffffff;
        }
        .metric-value.purple {
            color: #ffa726;
        }

        button {
            background: rgba(41, 182, 246, 0.2);
            color: #29b6f6;
            border: 1px solid rgba(41, 182, 246, 0.5);
            padding: 14px 28px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-family: 'Inter', sans-serif;
            box-shadow: 0 0 20px rgba(41, 182, 246, 0.1);
        }

        button:hover {
            background: rgba(41, 182, 246, 0.3);
            border-color: rgba(41, 182, 246, 0.7);
            box-shadow: 0 0 30px rgba(41, 182, 246, 0.3);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .log {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Inter', monospace;
            font-size: 11px;
            background: rgba(10, 25, 41, 0.5);
            padding: 12px;
            border-radius: 6px;
            border: 1px solid rgba(41, 182, 246, 0.15);
        }

        .log-entry {
            padding: 4px 0;
            color: #b0bec5;
        }

        .log-entry.error {
            color: #ef5350;
        }

        .log-entry.success {
            color: #26c6da;
        }

        .log-entry .timestamp {
            color: #546e7a;
        }

        /* Contact Table Styles */
        .contact-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            margin-top: 15px;
        }

        .contact-table thead {
            background: rgba(255, 167, 38, 0.15);
            border-bottom: 2px solid rgba(255, 167, 38, 0.3);
        }

        .contact-table th {
            padding: 10px 8px;
            text-align: left;
            color: #ffa726;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 11px;
        }

        .contact-table td {
            padding: 8px;
            border-bottom: 1px solid rgba(41, 182, 246, 0.1);
            color: #ffffff;
        }

        .contact-table tbody tr {
            transition: background 0.2s;
        }

        .contact-table tbody tr:hover {
            background: rgba(41, 182, 246, 0.1);
        }

        .contact-table tbody tr.selected {
            background: rgba(38, 198, 218, 0.2);
            border-left: 3px solid #26c6da;
        }

        .threat-level-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .threat-level-indicator.green {
            background: #26c6da;
            box-shadow: 0 0 8px rgba(38, 198, 218, 0.5);
        }

        .threat-level-indicator.yellow {
            background: #ffa726;
            box-shadow: 0 0 8px rgba(255, 167, 38, 0.5);
        }

        .threat-level-indicator.orange {
            background: #ff7043;
            box-shadow: 0 0 8px rgba(255, 112, 67, 0.5);
        }

        .threat-level-indicator.red {
            background: #ef5350;
            box-shadow: 0 0 8px rgba(239, 83, 80, 0.5);
            animation: pulse 1s infinite;
        }

        .track-id {
            font-family: 'Inter', monospace;
            font-weight: 600;
            color: #26c6da;
        }

        .acknowledge-btn {
            padding: 4px 10px;
            font-size: 10px;
            border-radius: 4px;
            background: rgba(38, 198, 218, 0.2);
            border: 1px solid rgba(38, 198, 218, 0.5);
            color: #26c6da;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .acknowledge-btn:hover {
            background: rgba(38, 198, 218, 0.3);
        }

        .export-btn {
            padding: 10px 20px;
            font-size: 11px;
            margin-top: 10px;
            width: 100%;
        }

        /* Threat Queue */
        .threat-queue-item {
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 6px;
            border-left: 3px solid;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }

        .threat-queue-item.critical {
            background: rgba(239, 83, 80, 0.15);
            border-color: #ef5350;
        }

        .threat-queue-item.high {
            background: rgba(255, 112, 67, 0.15);
            border-color: #ff7043;
        }

        .threat-queue-item.medium {
            background: rgba(255, 167, 38, 0.15);
            border-color: #ffa726;
        }

        .threat-queue-item.low {
            background: rgba(38, 198, 218, 0.15);
            border-color: #26c6da;
        }

        .threat-queue-item:hover {
            transform: translateX(4px);
        }

        .threat-time {
            font-size: 10px;
            color: #78909c;
        }

        .no-contacts {
            text-align: center;
            padding: 30px;
            color: #78909c;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üéØ SkyGuard Tactical</h1>
            <p class="subtitle">Real-Time Drone Detection System</p>

            <!-- Training Status -->
            <div style="background: rgba(38, 198, 218, 0.15); border: 1px solid rgba(38, 198, 218, 0.5); border-radius: 6px; padding: 12px; margin: 15px 0; text-align: center;">
                <strong style="color: #26c6da;">‚úì MODEL TRAINED</strong>
                <div style="font-size: 12px; margin-top: 4px; color: #b0bec5;">
                    83.03% validation accuracy on synthetic acoustic signatures. 11 drone classes. 1650 training samples.
                </div>
            </div>

            <div class="status-bar">
                <div class="status-badge" id="wsStatus">
                    <div class="status-dot"></div>
                    <span>Disconnected</span>
                </div>
                <div class="status-badge connected">
                    <span>4-Stage Pipeline</span>
                </div>
                <div class="status-badge connected">
                    <span>15ms Latency</span>
                </div>
            </div>
        </header>

        <!-- Active Contacts Table -->
        <div class="card" style="margin-bottom: 20px;">
            <h3>üéØ Active Contacts <span id="contactCount" style="color: #26c6da; font-size: 14px;">(0)</span></h3>
            <div style="overflow-x: auto;">
                <table class="contact-table">
                    <thead>
                        <tr>
                            <th>Track ID</th>
                            <th>Classification</th>
                            <th>Conf.</th>
                            <th>Bearing</th>
                            <th>Distance</th>
                            <th>Freq (Hz)</th>
                            <th>First Det.</th>
                            <th>Last Det.</th>
                            <th>Threat</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody id="contactTableBody">
                        <tr>
                            <td colspan="10" class="no-contacts">No active contacts detected</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <button class="export-btn" onclick="exportContactLog()">
                üì• Export Contact Log (CSV)
            </button>
        </div>

        <div class="main-grid">
            <div>
                <!-- Threat Status - Compact -->
                <div class="threat-status clear" id="threatStatus" style="padding: 20px; margin-bottom: 15px;">
                    <div class="threat-text" style="font-size: 32px;" id="threatText">ALL CLEAR</div>
                    <div class="confidence-text" style="font-size: 18px;" id="confidenceText"></div>
                </div>

                <!-- Detection Results -->
                <div class="card" id="detectionCard">
                    <h3>Detection Results</h3>
                    <div class="info-row">
                        <span class="info-label">Classification:</span>
                        <span class="info-value" id="classification">Non-Drone</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Confidence:</span>
                        <span class="info-value" id="confidence">0.0%</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Processing Time:</span>
                        <span class="info-value" id="latency">0.0ms</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">OOD Status:</span>
                        <span class="info-value" id="oodStatus">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Dominant Frequency:</span>
                        <span class="info-value" id="frequency">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Proximity:</span>
                        <span class="info-value" id="proximity">-</span>
                    </div>
                </div>

                <!-- Tactical Intel (Drone Specs) -->
                <div class="card" id="tacticalIntel" style="display: none;">
                    <h3>üéØ Tactical Intelligence</h3>
                    <div class="info-row">
                        <span class="info-label">Weight:</span>
                        <span class="info-value" id="specWeight">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Weight Class:</span>
                        <span class="info-value" id="specWeightClass">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Max Range:</span>
                        <span class="info-value" id="specRange">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Max Flight Time:</span>
                        <span class="info-value" id="specFlightTime">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Max Speed:</span>
                        <span class="info-value" id="specSpeed">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Threat Level:</span>
                        <span class="info-value" id="specThreat">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Camera:</span>
                        <span class="info-value" style="font-size: 12px;" id="specCamera">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Acoustic Signature:</span>
                        <span class="info-value" style="font-size: 11px;" id="specAcoustic">-</span>
                    </div>
                    <div style="margin-top: 15px; padding: 12px; background: rgba(59, 130, 246, 0.1); border-radius: 6px; border-left: 3px solid #3b82f6;">
                        <div style="font-size: 11px; color: #94a3b8; margin-bottom: 4px;">Description:</div>
                        <div style="font-size: 13px; line-height: 1.5;" id="specDescription">-</div>
                    </div>
                    <div id="specSpecialNote" style="display: none; margin-top: 10px; padding: 10px; background: rgba(234, 179, 8, 0.1); border-radius: 6px; border-left: 3px solid #eab308;">
                        <div style="font-size: 11px; color: #94a3b8; margin-bottom: 4px;">‚ö†Ô∏è Special Note:</div>
                        <div style="font-size: 12px; line-height: 1.5;" id="specSpecialNoteText">-</div>
                    </div>
                </div>

                <!-- System Log -->
                <div class="card">
                    <h3>System Log</h3>
                    <div class="log" id="systemLog"></div>
                </div>
            </div>

            <div>
                <!-- Threat Queue -->
                <div class="card" style="margin-bottom: 20px;">
                    <h3>‚ö†Ô∏è Threat Queue</h3>
                    <div id="threatQueue">
                        <div class="no-contacts">No active threats</div>
                    </div>
                </div>

                <!-- Performance Metrics -->
                <div class="card">
                    <h3>Performance</h3>
                    <div class="metric">
                        <div class="metric-label">Average Latency</div>
                        <div class="metric-value green" id="avgLatency">--</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Model Accuracy</div>
                        <div class="metric-value blue">83.03%</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Detections</div>
                        <div class="metric-value purple" id="detectionCount">0</div>
                    </div>
                </div>

                <!-- Controls -->
                <div class="card">
                    <h3>Controls</h3>
                    <button id="connectBtn" onclick="connectWebSocket()">Connect to Backend</button>
                    <button id="startBtn" onclick="startDetection()" style="margin-top: 12px; background: rgba(38, 198, 218, 0.2); border-color: rgba(38, 198, 218, 0.5); color: #26c6da;" disabled>Start Detection</button>
                    <button id="stopBtn" onclick="stopDetection()" style="margin-top: 12px; background: rgba(239, 83, 80, 0.2); border-color: rgba(239, 83, 80, 0.5); color: #ef5350;" disabled>Stop Detection</button>
                    <button id="resetBtn" onclick="resetPipeline()" style="margin-top: 12px; background: rgba(144, 202, 249, 0.2); border-color: rgba(144, 202, 249, 0.5); color: #90caf9;" disabled>Reset Pipeline</button>
                </div>

                <!-- System Info -->
                <div class="card">
                    <h3>System Info</h3>
                    <div class="info-row">
                        <span class="info-label">Backend:</span>
                        <span class="info-value">localhost:8000</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Pipeline:</span>
                        <span class="info-value">Harmonic ‚Üí CNN ‚Üí OOD ‚Üí Smoother</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Model Status:</span>
                        <span class="info-value" style="color: #26c6da;">‚úì TRAINED (83.03% acc)</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Training Data:</span>
                        <span class="info-value">1650 synthetic samples</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Drone Classes:</span>
                        <span class="info-value">11 (10 models + Non-Drone)</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Sample Rate:</span>
                        <span class="info-value">16kHz</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Audio Visualizers -->
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
            <!-- Waveform & Spectrogram -->
            <div class="card">
                <h3>üìä Audio Waveform</h3>
                <canvas id="waveformCanvas" width="550" height="150" style="width: 100%; background: rgba(10, 15, 25, 0.5); border-radius: 4px;"></canvas>
                <h3 style="margin-top: 20px;">üåà Frequency Spectrogram</h3>
                <canvas id="spectrogramCanvas" width="550" height="200" style="width: 100%; background: rgba(10, 15, 25, 0.5); border-radius: 4px; margin-top: 10px;"></canvas>
            </div>

            <!-- Tactical Radar -->
            <div class="card">
                <h3>üéØ Tactical Radar</h3>
                <canvas id="radarCanvas" width="400" height="400" style="width: 100%; background: rgba(10, 15, 25, 0.5); border-radius: 4px;"></canvas>
                <div style="margin-top: 15px; text-align: center; font-size: 12px; color: #64748b;">
                    <div><span style="color: #4ade80;">‚óè</span> Detected Drone</div>
                    <div><span style="color: #60a5fa;">‚óè</span> Audio Source Direction</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let ws = null;
        let isConnected = false;
        let audioContext = null;
        let mediaStream = null;
        let processor = null;
        let isRecording = false;
        let lastAudioLevel = 0;

        // Performance tracking
        let latencySum = 0;
        let latencyCount = 0;
        let detectionCount = 0;

        // Contact tracking
        let activeContacts = new Map(); // Track ID -> Contact object
        let nextTrackId = 1;
        let contactLog = []; // Full log for export
        let threatQueue = [];

        function addLog(message, type = 'info') {
            const log = document.getElementById('systemLog');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.innerHTML = `<span class="timestamp">[${timestamp}]</span> ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;

            // Keep only last 50 entries
            while (log.children.length > 50) {
                log.removeChild(log.firstChild);
            }
        }

        function updateStatus(connected) {
            isConnected = connected;
            const statusBadge = document.getElementById('wsStatus');
            const connectBtn = document.getElementById('connectBtn');
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');
            const resetBtn = document.getElementById('resetBtn');

            if (connected) {
                statusBadge.className = 'status-badge connected';
                statusBadge.innerHTML = '<div class="status-dot pulse"></div><span>Connected</span>';
                connectBtn.textContent = 'Disconnect';
                connectBtn.style.background = 'rgba(239, 83, 80, 0.2)';
                connectBtn.style.borderColor = 'rgba(239, 83, 80, 0.5)';
                connectBtn.style.color = '#ef5350';
                startBtn.disabled = false;
                resetBtn.disabled = false;
                addLog('‚úì Connected to backend', 'success');
            } else {
                statusBadge.className = 'status-badge disconnected';
                statusBadge.innerHTML = '<div class="status-dot"></div><span>Disconnected</span>';
                connectBtn.textContent = 'Connect to Backend';
                connectBtn.style.background = 'rgba(41, 182, 246, 0.2)';
                connectBtn.style.borderColor = 'rgba(41, 182, 246, 0.5)';
                connectBtn.style.color = '#29b6f6';
                startBtn.disabled = true;
                stopBtn.disabled = true;
                resetBtn.disabled = true;
                addLog('‚úó Disconnected from backend', 'error');
            }
        }

        function updateThreatDisplay(detected, confidence) {
            const threatStatus = document.getElementById('threatStatus');
            const threatText = document.getElementById('threatText');
            const confidenceText = document.getElementById('confidenceText');

            let level = 'clear';
            let text = 'ALL CLEAR';

            if (detected) {
                if (confidence >= 0.9) {
                    level = 'high';
                    text = 'HIGH THREAT';
                } else if (confidence >= 0.7) {
                    level = 'detected';
                    text = 'THREAT DETECTED';
                } else {
                    level = 'possible';
                    text = 'POSSIBLE THREAT';
                }
                confidenceText.textContent = `Confidence: ${(confidence * 100).toFixed(1)}%`;
            } else {
                confidenceText.textContent = '';
            }

            threatStatus.className = `threat-status ${level}`;
            threatText.textContent = text;
        }

        function updateDetectionResults(result) {
            // Flash individual values when they update
            function flashElement(id) {
                const el = document.getElementById(id);
                el.classList.remove('flash');
                void el.offsetWidth; // Force reflow
                el.classList.add('flash');
            }

            // Show what stage filtered it
            const stageInfo = result.stage === 'harmonic_filter' ? ' [Filtered by Harmonics]' : ' [Full Pipeline]';

            document.getElementById('classification').textContent = result.class_name + stageInfo;
            flashElement('classification');

            document.getElementById('confidence').textContent = `${(result.confidence * 100).toFixed(1)}%`;
            flashElement('confidence');

            document.getElementById('latency').textContent = `${result.latency_ms.toFixed(1)}ms`;
            flashElement('latency');

            document.getElementById('oodStatus').textContent = result.is_ood ? '‚ö†Ô∏è Unknown' : '‚úì Known';
            flashElement('oodStatus');

            const freqValue = result.dominant_frequency ? `${result.dominant_frequency.toFixed(0)} Hz` : '-';
            document.getElementById('frequency').textContent = freqValue;
            flashElement('frequency');

            // Update performance metrics
            latencySum += result.latency_ms;
            latencyCount++;
            const avgLatency = (latencySum / latencyCount).toFixed(1);
            document.getElementById('avgLatency').textContent = `${avgLatency}ms`;

            // Track detections
            if (result.detected && result.class_name !== 'Non-Drone') {
                detectionCount++;
                document.getElementById('detectionCount').textContent = detectionCount;
            }

            // Calculate proximity from audio level
            let proximity = 'UNKNOWN';
            if (lastAudioLevel > 0.5) proximity = 'üî¥ CLOSE';
            else if (lastAudioLevel > 0.2) proximity = 'üü° MEDIUM';
            else if (lastAudioLevel > 0.05) proximity = 'üü¢ FAR';
            else proximity = '‚ö™ SILENT';
            document.getElementById('proximity').textContent = proximity;
            flashElement('proximity');

            updateThreatDisplay(result.detected, result.confidence);

            // Add/update contact tracking
            addOrUpdateContact(result);

            // Update tactical intel specs
            const tacticalIntel = document.getElementById('tacticalIntel');
            if (result.specs && result.class_name !== 'Non-Drone') {
                tacticalIntel.style.display = 'block';

                document.getElementById('specWeight').textContent =
                    result.specs.weight_kg ? `${result.specs.weight_kg} kg` : 'Unknown';
                document.getElementById('specWeightClass').textContent =
                    result.specs.weight_class || 'Unknown';
                document.getElementById('specRange').textContent =
                    result.specs.max_range_km ? `${result.specs.max_range_km} km` : 'Unknown';
                document.getElementById('specFlightTime').textContent =
                    result.specs.max_flight_time_min ? `${result.specs.max_flight_time_min} min` : 'Unknown';
                document.getElementById('specSpeed').textContent =
                    result.specs.max_speed_kph ? `${result.specs.max_speed_kph} km/h` : 'Unknown';
                document.getElementById('specThreat').textContent =
                    result.specs.threat_level || 'Unknown';
                document.getElementById('specCamera').textContent =
                    result.specs.camera || 'N/A';
                document.getElementById('specAcoustic').textContent =
                    result.specs.acoustic_signature || 'N/A';
                document.getElementById('specDescription').textContent =
                    result.specs.description || 'No description available';

                // Show special note if present
                const specialNoteDiv = document.getElementById('specSpecialNote');
                if (result.specs.special_note) {
                    specialNoteDiv.style.display = 'block';
                    document.getElementById('specSpecialNoteText').textContent = result.specs.special_note;
                } else {
                    specialNoteDiv.style.display = 'none';
                }
            } else {
                tacticalIntel.style.display = 'none';
            }

            // Update radar blip when drone detected
            if (result.detected && result.class_name !== 'Non-Drone') {
                // Trigger radar blip
                radarBlipIntensity = 1.0;

                // Simulate bearing based on dominant frequency (for demo purposes)
                // In a real system, would need microphone array for true direction finding
                if (result.dominant_frequency) {
                    // Map frequency to bearing (just for visualization)
                    detectedBearing = (result.dominant_frequency / 50) % 360;
                } else {
                    detectedBearing = Math.random() * 360;
                }

                addLog(`üö® DETECTED: ${result.class_name} (${(result.confidence * 100).toFixed(1)}%) ${stageInfo}`, 'error');
            } else if (result.stage === 'harmonic_filter') {
                // Log when harmonic filter rejects
                addLog(`‚úì Harmonic filter rejected: ${result.class_name}`, 'success');
            } else {
                // Log low confidence detections
                addLog(`‚úì Low confidence: ${result.class_name} (${(result.confidence * 100).toFixed(1)}%)`, 'success');
            }
        }

        function addOrUpdateContact(result) {
            if (!result.detected || result.class_name === 'Non-Drone') {
                return;
            }

            const now = Date.now();
            let trackId = null;

            // Check if this is an existing contact (match by classification and similar frequency)
            for (const [id, contact] of activeContacts) {
                if (contact.classification === result.class_name &&
                    Math.abs(contact.frequency - result.dominant_frequency) < 100) {
                    trackId = id;
                    break;
                }
            }

            // New contact
            if (!trackId) {
                trackId = `T${String(nextTrackId++).padStart(3, '0')}`;

                const contact = {
                    trackId,
                    classification: result.class_name,
                    confidence: result.confidence,
                    frequency: result.dominant_frequency,
                    bearing: result.dominant_frequency ? ((result.dominant_frequency / 50) % 360).toFixed(0) : 'UNK',
                    distance: estimateDistance(lastAudioLevel),
                    firstDetected: now,
                    lastDetected: now,
                    detectionCount: 1,
                    threatLevel: assessThreatLevel(result.confidence, lastAudioLevel),
                    acknowledged: false
                };

                activeContacts.set(trackId, contact);

                // Add to threat queue
                addToThreatQueue(contact);

                // Log to export buffer
                contactLog.push({...contact, timestamp: new Date().toISOString()});

                addLog(`üö® NEW CONTACT: ${trackId} - ${result.class_name} (${(result.confidence * 100).toFixed(1)}%)`, 'error');
            } else {
                // Update existing contact
                const contact = activeContacts.get(trackId);
                contact.confidence = Math.max(contact.confidence, result.confidence);
                contact.lastDetected = now;
                contact.detectionCount++;
                contact.threatLevel = assessThreatLevel(contact.confidence, lastAudioLevel);
                contact.distance = estimateDistance(lastAudioLevel);
            }

            updateContactTable();
            updateContactCount();
        }

        function estimateDistance(audioLevel) {
            // Rough estimation based on audio level
            if (audioLevel > 0.7) return '< 50m';
            if (audioLevel > 0.4) return '50-100m';
            if (audioLevel > 0.2) return '100-200m';
            if (audioLevel > 0.05) return '200-500m';
            return '> 500m';
        }

        function assessThreatLevel(confidence, audioLevel) {
            // Critical: High confidence + close proximity
            if (confidence > 0.85 && audioLevel > 0.5) return 'red';
            // High: High confidence OR close proximity
            if (confidence > 0.7 || audioLevel > 0.5) return 'orange';
            // Medium: Moderate confidence
            if (confidence > 0.5) return 'yellow';
            // Low: Detected but low confidence
            return 'green';
        }

        function updateContactTable() {
            const tbody = document.getElementById('contactTableBody');

            if (activeContacts.size === 0) {
                tbody.innerHTML = '<tr><td colspan="10" class="no-contacts">No active contacts detected</td></tr>';
                return;
            }

            const rows = Array.from(activeContacts.values())
                .sort((a, b) => {
                    const threatOrder = {red: 0, orange: 1, yellow: 2, green: 3};
                    return threatOrder[a.threatLevel] - threatOrder[b.threatLevel];
                });

            tbody.innerHTML = rows.map(contact => {
                const elapsed = Math.floor((Date.now() - contact.firstDetected) / 1000);
                const lastSeen = Math.floor((Date.now() - contact.lastDetected) / 1000);

                return `
                    <tr>
                        <td><span class="track-id">${contact.trackId}</span></td>
                        <td>${contact.classification}</td>
                        <td>${(contact.confidence * 100).toFixed(0)}%</td>
                        <td>${contact.bearing}¬∞</td>
                        <td>${contact.distance}</td>
                        <td>${contact.frequency ? contact.frequency.toFixed(0) : 'N/A'}</td>
                        <td>${elapsed}s ago</td>
                        <td>${lastSeen}s ago</td>
                        <td>
                            <span class="threat-level-indicator ${contact.threatLevel}"></span>
                            ${contact.threatLevel.toUpperCase()}
                        </td>
                        <td>
                            <button class="acknowledge-btn" onclick="acknowledgeContact('${contact.trackId}')">
                                ${contact.acknowledged ? '‚úì ACK' : 'ACK'}
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function updateContactCount() {
            document.getElementById('contactCount').textContent = `(${activeContacts.size})`;
        }

        function addToThreatQueue(contact) {
            const threat = {
                trackId: contact.trackId,
                classification: contact.classification,
                threatLevel: contact.threatLevel,
                timestamp: Date.now()
            };

            threatQueue.unshift(threat);
            if (threatQueue.length > 10) threatQueue.pop(); // Keep last 10

            updateThreatQueue();
        }

        function updateThreatQueue() {
            const queueDiv = document.getElementById('threatQueue');

            if (threatQueue.length === 0) {
                queueDiv.innerHTML = '<div class="no-contacts">No active threats</div>';
                return;
            }

            queueDiv.innerHTML = threatQueue.map(threat => {
                const elapsed = Math.floor((Date.now() - threat.timestamp) / 1000);
                const levelText = {red: 'CRITICAL', orange: 'HIGH', yellow: 'MEDIUM', green: 'LOW'}[threat.threatLevel];

                return `
                    <div class="threat-queue-item ${threat.threatLevel === 'red' ? 'critical' : threat.threatLevel === 'orange' ? 'high' : threat.threatLevel === 'yellow' ? 'medium' : 'low'}">
                        <div>
                            <strong>${threat.trackId}</strong> - ${threat.classification}
                            <div class="threat-time">${elapsed}s ago</div>
                        </div>
                        <span style="font-weight: 600; font-size: 11px;">${levelText}</span>
                    </div>
                `;
            }).join('');
        }

        function acknowledgeContact(trackId) {
            const contact = activeContacts.get(trackId);
            if (contact) {
                contact.acknowledged = true;
                updateContactTable();
                addLog(`‚úì Acknowledged contact ${trackId}`, 'success');
            }
        }

        function exportContactLog() {
            const csv = [
                ['Timestamp', 'Track ID', 'Classification', 'Confidence', 'Bearing', 'Distance', 'Frequency', 'Threat Level', 'Detection Count'].join(','),
                ...contactLog.map(c => [
                    c.timestamp,
                    c.trackId,
                    c.classification,
                    (c.confidence * 100).toFixed(1) + '%',
                    c.bearing + '¬∞',
                    c.distance,
                    c.frequency ? c.frequency.toFixed(0) : 'N/A',
                    c.threatLevel.toUpperCase(),
                    c.detectionCount
                ].join(','))
            ].join('\n');

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `skyguard_contacts_${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            URL.revokeObjectURL(url);

            addLog('üì• Contact log exported', 'success');
        }

        // Auto-cleanup stale contacts (> 30 seconds since last detection)
        setInterval(() => {
            const now = Date.now();
            for (const [trackId, contact] of activeContacts) {
                if (now - contact.lastDetected > 30000) {
                    activeContacts.delete(trackId);
                    addLog(`Contact ${trackId} dropped (timeout)`, 'info');
                }
            }
            updateContactTable();
            updateContactCount();
        }, 5000);

        function connectWebSocket() {
            if (isConnected && ws) {
                // Disconnect
                ws.close();
                return;
            }

            // Connect
            addLog('Connecting to ws://localhost:8000/ws/audio...');

            ws = new WebSocket('ws://localhost:8000/ws/audio');

            ws.onopen = () => {
                updateStatus(true);

                // Send periodic ping to keep connection alive
                setInterval(() => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({ type: 'ping' }));
                    }
                }, 30000);
            };

            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);

                if (message.type === 'detection') {
                    updateDetectionResults(message.data);
                } else if (message.type === 'error') {
                    addLog(`‚ùå Error: ${message.message}`, 'error');
                } else if (message.type === 'pong') {
                    // Keep-alive response
                } else if (message.type === 'reset_ack') {
                    addLog('‚úì Pipeline reset', 'success');
                }
            };

            ws.onerror = (error) => {
                addLog('‚ùå WebSocket error - is backend running?', 'error');
                console.error('WebSocket error:', error);
            };

            ws.onclose = () => {
                updateStatus(false);
                ws = null;
            };
        }

        async function startDetection() {
            if (!ws || !isConnected) {
                addLog('‚ùå Not connected to backend', 'error');
                return;
            }

            try {
                addLog('Requesting microphone access...');

                // Get microphone without forcing sample rate (browser will choose)
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });

                // Create AudioContext without forcing sample rate
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(mediaStream);

                // Use buffer size that matches 3 seconds at native sample rate
                const bufferSize = 16384; // Power of 2, approximately 0.37s at 44.1kHz
                processor = audioContext.createScriptProcessor(bufferSize, 1, 1);

                processor.onaudioprocess = (e) => {
                    if (isRecording && ws && ws.readyState === WebSocket.OPEN) {
                        const audioData = e.inputBuffer.getChannelData(0);

                        // Calculate audio level for proximity
                        const level = Math.sqrt(
                            audioData.reduce((sum, val) => sum + val * val, 0) / audioData.length
                        );
                        lastAudioLevel = level;

                        // Resample to 16kHz if needed
                        const nativeSampleRate = audioContext.sampleRate;
                        let resampledAudio = audioData;

                        if (nativeSampleRate !== 16000) {
                            const targetLength = Math.floor(audioData.length * 16000 / nativeSampleRate);
                            resampledAudio = new Float32Array(targetLength);
                            const ratio = audioData.length / targetLength;

                            for (let i = 0; i < targetLength; i++) {
                                const srcIndex = i * ratio;
                                const srcIndexFloor = Math.floor(srcIndex);
                                const srcIndexCeil = Math.min(srcIndexFloor + 1, audioData.length - 1);
                                const fraction = srcIndex - srcIndexFloor;

                                // Linear interpolation
                                resampledAudio[i] = audioData[srcIndexFloor] * (1 - fraction) +
                                                   audioData[srcIndexCeil] * fraction;
                            }
                        }

                        // Convert to base64
                        const bytes = new Float32Array(resampledAudio);
                        const binary = new Uint8Array(bytes.buffer);
                        let binaryString = '';
                        for (let i = 0; i < binary.length; i++) {
                            binaryString += String.fromCharCode(binary[i]);
                        }
                        const base64Audio = btoa(binaryString);

                        ws.send(JSON.stringify({
                            type: 'audio',
                            data: base64Audio,
                            sample_rate: 16000
                        }));
                    }
                };

                source.connect(processor);
                processor.connect(audioContext.destination);

                isRecording = true;
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;

                // Initialize visualizers
                initializeVisualizers();

                addLog('‚úì Detection started - monitoring audio', 'success');

            } catch (error) {
                addLog(`‚ùå Microphone error: ${error.message}`, 'error');
                console.error('Error starting detection:', error);
            }
        }

        function stopDetection() {
            isRecording = false;

            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
            }
            if (audioContext) {
                audioContext.close();
            }

            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            addLog('Detection stopped');
        }

        function resetPipeline() {
            if (!ws || !isConnected) {
                addLog('‚ùå Not connected to backend', 'error');
                return;
            }

            ws.send(JSON.stringify({ type: 'reset' }));
            addLog('Resetting pipeline...');

            // Reset performance counters
            latencySum = 0;
            latencyCount = 0;
            detectionCount = 0;
            document.getElementById('avgLatency').textContent = '--';
            document.getElementById('detectionCount').textContent = '0';

            // Reset contact tracking
            activeContacts.clear();
            nextTrackId = 1;
            threatQueue = [];
            updateContactTable();
            updateContactCount();
            updateThreatQueue();

            // Reset UI
            updateThreatDisplay(false, 0);
            document.getElementById('classification').textContent = 'Non-Drone';
            document.getElementById('confidence').textContent = '0.0%';
            document.getElementById('latency').textContent = '0.0ms';
            document.getElementById('oodStatus').textContent = '-';
            document.getElementById('frequency').textContent = '-';
            document.getElementById('proximity').textContent = '-';
        }

        // Initialize
        addLog('SkyGuard Tactical initialized');
        addLog('Click "Connect to Backend" to start');

        // ========================================
        // AUDIO VISUALIZATIONS
        // ========================================

        let analyser = null;
        let dataArray = null;
        let bufferLength = 0;
        let spectrogramHistory = [];
        let detectedBearing = 0; // Simulated bearing in degrees
        let radarBlipIntensity = 0;

        function initializeVisualizers() {
            if (!audioContext) return;

            // Create analyser for frequency data
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);

            // Connect microphone source to analyser
            if (mediaStream) {
                const source = audioContext.createMediaStreamSource(mediaStream);
                source.connect(analyser);
            }

            // Start animation loop
            animateVisualizers();
        }

        function animateVisualizers() {
            requestAnimationFrame(animateVisualizers);

            if (!analyser || !isRecording) return;

            // Get audio data
            analyser.getByteTimeDomainData(dataArray);
            const freqData = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(freqData);

            // Draw waveform
            drawWaveform(dataArray);

            // Draw spectrogram
            drawSpectrogram(freqData);

            // Draw radar
            drawRadar();
        }

        function drawWaveform(data) {
            const canvas = document.getElementById('waveformCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);

            // Draw grid
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                const y = (height / 4) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // Draw waveform
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#3b82f6';
            ctx.beginPath();

            const sliceWidth = width / bufferLength;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
                const v = data[i] / 128.0;
                const y = (v * height) / 2;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }

                x += sliceWidth;
            }

            ctx.stroke();

            // Add glow effect for active signal
            if (lastAudioLevel > 0.1) {
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#3b82f6';
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
        }

        function drawSpectrogram(freqData) {
            const canvas = document.getElementById('spectrogramCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Scroll existing data left
            const imageData = ctx.getImageData(1, 0, width - 1, height);
            ctx.putImageData(imageData, 0, 0);

            // Draw new column on right
            const barHeight = height / bufferLength;

            for (let i = 0; i < bufferLength; i++) {
                const value = freqData[i];
                const percent = value / 255;

                // Color gradient based on intensity
                let r, g, b;
                if (percent < 0.3) {
                    r = 15; g = 23; b = 42; // Dark blue (background)
                } else if (percent < 0.5) {
                    r = 59; g = 130; b = 246; // Blue
                } else if (percent < 0.7) {
                    r = 34; g = 197; b = 94; // Green
                } else if (percent < 0.9) {
                    r = 234; g = 179; b = 8; // Yellow
                } else {
                    r = 239; g = 68; b = 68; // Red
                }

                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(width - 1, height - (i * barHeight), 1, barHeight);
            }

            // Draw frequency labels
            ctx.fillStyle = '#64748b';
            ctx.font = '10px monospace';
            ctx.fillText('0 Hz', 5, height - 5);
            ctx.fillText('8 kHz', 5, 15);
        }

        function drawRadar() {
            const canvas = document.getElementById('radarCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(width, height) / 2 - 20;

            // Clear
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);

            // Draw radar circles
            ctx.strokeStyle = 'rgba(59, 130, 246, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 4; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, (maxRadius / 4) * i, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw crosshairs
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - maxRadius);
            ctx.lineTo(centerX, centerY + maxRadius);
            ctx.moveTo(centerX - maxRadius, centerY);
            ctx.lineTo(centerX + maxRadius, centerY);
            ctx.stroke();

            // Draw cardinal directions
            ctx.fillStyle = '#64748b';
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('N', centerX, centerY - maxRadius - 5);
            ctx.fillText('S', centerX, centerY + maxRadius + 15);
            ctx.textAlign = 'right';
            ctx.fillText('W', centerX - maxRadius - 5, centerY + 5);
            ctx.textAlign = 'left';
            ctx.fillText('E', centerX + maxRadius + 5, centerY + 5);

            // Draw sweeping radar line (animated)
            const sweepAngle = (Date.now() / 20) % 360;
            const sweepRad = (sweepAngle * Math.PI) / 180;
            ctx.strokeStyle = 'rgba(34, 197, 94, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
                centerX + Math.cos(sweepRad - Math.PI / 2) * maxRadius,
                centerY + Math.sin(sweepRad - Math.PI / 2) * maxRadius
            );
            ctx.stroke();

            // Draw detected drone blip
            if (radarBlipIntensity > 0) {
                // Simulate bearing based on dominant frequency
                // (In reality, would need microphone array for true bearing)
                const blipAngle = (detectedBearing * Math.PI) / 180;
                const blipDistance = maxRadius * 0.6; // Simulate distance

                const blipX = centerX + Math.cos(blipAngle - Math.PI / 2) * blipDistance;
                const blipY = centerY + Math.sin(blipAngle - Math.PI / 2) * blipDistance;

                // Pulsing effect
                const pulse = Math.sin(Date.now() / 200) * 0.3 + 0.7;

                // Draw blip with glow
                ctx.shadowBlur = 20 * pulse;
                ctx.shadowColor = '#22c55e';
                ctx.fillStyle = `rgba(34, 197, 94, ${radarBlipIntensity * pulse})`;
                ctx.beginPath();
                ctx.arc(blipX, blipY, 8, 0, Math.PI * 2);
                ctx.fill();

                // Draw rings around blip
                ctx.strokeStyle = `rgba(34, 197, 94, ${radarBlipIntensity * 0.5})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(blipX, blipY, 12 * pulse, 0, Math.PI * 2);
                ctx.stroke();

                ctx.shadowBlur = 0;

                // Decay intensity
                radarBlipIntensity *= 0.98;
            }
        }

        addLog('Click "Connect to Backend" to start');

        // Auto-connect if backend is available
        fetch('http://localhost:8000/')
            .then(res => res.json())
            .then(data => {
                if (data.status === 'online') {
                    addLog('‚úì Backend detected', 'success');
                    addLog('Ready to connect');
                }
            })
            .catch(() => {
                addLog('‚ö†Ô∏è Backend offline - start with: python3 backend/main.py', 'error');
            });
    </script>
</body>
</html>
